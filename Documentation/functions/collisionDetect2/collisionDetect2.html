<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>collisionDetect2.c</title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<div id="header">
<h1 class="title">collisionDetect2.c</h1>
</div>
<div id="TOC">
<ul>
<li><a href="#pttotrimeshcollision">ptToTriMeshCollision()</a></li>
<li><a href="#pttoquadmeshcollision">ptToQuadMeshCollision()</a></li>
<li><a href="#pttotricollision">ptToTriCollision()</a></li>
<li><a href="#pttotrimeshzcollision">ptToTriMeshZCollision()</a></li>
<li><a href="#pttoquadmeshzcollision">ptToQuadMeshZCollision()</a></li>
</ul>
</div>
<hr />
<h3 id="pttotrimeshcollision">ptToTriMeshCollision()</h3>
<div class="figure">
<img src="0.png" />

</div>
<p>Determines where or if a point collided from the inside or outside of a mesh.</p>
<p>Note: makeTriTransData() must be used first to create transformation data for each polygon.</p>
<p>Note: Each individual triangle will be normalized to test for a collision. This could cause the point to miss and go through the cracks of the triangles because each has to be rotated differently to be normalized. This is where the &quot;errorMargin&quot; variable might be useful, however ptToQuadMeshZCollision() could be used instead which does not have this problem.</p>
<p><img src="1.png" /> <img src="2.png" /> if errorMargin equals 0.001</p>
<p>Note: If testing for when a point is inside a mesh and the mesh has both quads and triangles then make sure to use both ptToTriMeshCollision() and ptToQuadMeshCollision(). If the &quot;outside&quot; variable is true in both cases then it is outside of the mesh.</p>
<hr />
<h3 id="pttoquadmeshcollision">ptToQuadMeshCollision()</h3>
<p>Determines where or if a point collided from the inside or outside of a mesh.</p>
<p>Note: makeQuadTransData() must be used first to create transformation data for each polygon.</p>
<p>Note: Each individual triangle will be normalized to test for a collision. This could cause the point to miss and go through the cracks of the triangles because each has to be rotated differently to be normalized. This is where the &quot;errorMargin&quot; variable might be useful, however ptToQuadMeshZCollision() could be used instead which does not have this problem.</p>
<p>Note: If testing for when a point is inside a mesh and the mesh has both quads and triangles then make sure to use both ptToTriMeshCollision() and ptToQuadMeshCollision(). If the &quot;outside&quot; variable is true in both cases then it is outside of the mesh.</p>
<hr />
<h3 id="pttotricollision">ptToTriCollision()</h3>
<div class="figure">
<img src="3.png" />

</div>
<p>This function can be used to find where and what side of a triangle a point has collided.</p>
<hr />
<h3 id="pttotrimeshzcollision">ptToTriMeshZCollision()</h3>
<p>Can be used with getUCRotPointToAxisZ() to determine where or if a point collided from the inside or outside of a mesh.</p>
<p>Note: If testing for when a point is inside a mesh and the mesh has both quads and triangles then make sure to use both ptToTriMeshZCollision() and ptToQuadMeshZCollision(). If the &quot;outside&quot; variable is true in both cases then it is outside of the mesh.</p>
<hr />
<h3 id="pttoquadmeshzcollision">ptToQuadMeshZCollision()</h3>
<p>Can be used with getUCRotPointToAxisZ() to determine where or if a point collided from the inside or outside of a mesh.</p>
<p>Note: If testing for when a point is inside a mesh and the mesh has both quads and triangles then make sure to use both ptToTriMeshZCollision() and ptToQuadMeshZCollision(). If the &quot;outside&quot; variable is true in both cases then it is outside of the mesh.</p>
<hr />
</body>
</html>
